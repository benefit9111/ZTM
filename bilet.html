<!DOCTYPE html>
<html lang="pl">
<head>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Carlito:wght@400;700&display=swap">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bilet ZTM Kielce</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow-x: hidden;      /* bez poziomego scrollu */
      background: #eaeaea;     /* tło wokół biletu */
      font-family: "Carlito", Arial, sans-serif;
    }

    /* Centrowanie makiety na ekranie */
    .page {
      display: flex;
      justify-content: center;
    }

    /* Kontener strony-biletu */
    .ticket {
      position: relative;      /* kontekst dla absolutnych pozycji (logo, overlay) */
      display: inline-block;
      line-height: 0;
      user-select: none;
    }

    /* Tło jako <img> (rozciąga się do 100% szerokości kontenera) */
    .ticket img.bg {
      display: block;
      width: 100%;
      height: auto;
    }

    /* SCENA animacji: nad tłem, pozycje w % względem tła */
    .logo-stage {
      position: absolute;
      top: 28%;            /* pionowo względem wysokości tła */
      left: 5.4%;
      width: 89%;
      height: 47px;
      overflow: hidden;    /* obcięcie spoza sceny */
      pointer-events: none;
      z-index: 1;
    }

    /* Taśma (dwie kopie logo dla bezszwowości) */
    .logo-track {
      position: absolute;
      top: 50%;
      display: flex;
      align-items: center;
      gap: 245px;                                /* w razie potrzeby zmień np. na 90px */
      transform: translateY(-50%);
      animation: marqueeCycle var(--duration, 10s) linear infinite;
      animation-direction: reverse;              /* z lewej → w prawo */
      will-change: transform;
    }

    .logo-track img {
      height: 37px;
      flex: 0 0 auto;
      display: block;
    }

    @keyframes marqueeCycle {
      from { transform: translate(0, -50%); }
      to   { transform: translate(calc(var(--cycle, 0px) * -1), -50%); }
    }

    /* === Overlay i bloki tekstowe (konfigurowalne pozycje) === */
    .overlay {
      position: absolute;
      inset: 0;        /* pełen obszar tła */
      z-index: 2;      /* nad animacją logo */
      pointer-events: none;
      line-height: 1.2;
    }

    .text-block {
      position: absolute;
      top: var(--y, 0%);
      left: var(--x, 0%);
      transform: translate(-50%, -50%); /* domyślnie center */
      font-size: clamp(10px, var(--fs, 1.8vw), 26px);
      color: var(--color, #000);
      font-weight: var(--fw, 600);
      background: var(--bg, transparent);
      padding: 2px 6px;
      border-radius: 6px;
      white-space: nowrap;
      text-shadow: 0 1px 0 rgba(255,255,255,0.4);
    }
    .text-block[data-align="left"]   { transform: translate(0%,   -50%); text-align: left; }
    .text-block[data-align="center"] { transform: translate(-50%, -50%); text-align: center; }
    .text-block[data-align="right"]  { transform: translate(-100%,-50%); text-align: right; }
  </style>
</head>
<body>

  <div class="page">
    <div class="ticket">
      <!-- TŁO -->
      <img src="ztm.png" alt="tło biletu" class="bg">

      <!-- ANIMACJA LOGO -->
      <div class="logo-stage">
        <div class="logo-track">
          <img src="logo_ztm.png" alt="logo" />
          <img src="logo_ztm.png" alt="logo" />
        </div>
      </div>

      <!-- Nakładka z blokami tekstowymi (pozycje ustawiasz atrybutami data-*) -->
      <div class="overlay" id="overlay">

        <!-- Odliczanie do końca -->
        <div
          class="text-block"
          id="tb-countdown"
          data-x="50%" data-y="9.6%"
          data-align="center"
          data-fs="10.0vw"
          data-fw="800"
          data-color="#2b7729"
        >—</div>

        <!-- Data zakupu (używa czasu startu) -->
        <div
          class="text-block js-start-time"
          id="tb-purchase-time"
          data-x="8%" data-y="43.2%"
          data-align="left"
          data-fs="4.9vw"
          data-color="#000"
        >—</div>

        <!-- Ważny od (używa czasu startu) -->
        <div
          class="text-block js-start-time"
          id="tb-valid-from"
          data-x="8%" data-y="47.2%"
          data-align="left"
          data-fs="4.9vw"
          data-color="#000"
        >—</div>

        <!-- Ważny do (używa czasu końca) -->
        <div
          class="text-block js-valid-to"
          id="tb-valid-to"
          data-x="8%" data-y="51.2%"
          data-align="left"
          data-fs="4.9vw"
          data-color="#000"
        >—</div>

        <!-- Data skasowania biletu (używa czasu startu) -->
        <div
          class="text-block js-start-time"
          id="tb-cancel-time"
          data-x="8%" data-y="55.2%"
          data-align="left"
          data-fs="4.9vw"
          data-color="#000"
        >—</div>

        <!-- Czas od skasowania (licznik w górę, ten sam format m i s) -->
        <div
          class="text-block"
          id="tb-elapsed"
          data-x="8%" data-y="59.3%"
          data-align="left"
          data-fs="4.9vw"
          data-color="#b02432"
          data-fw="700"
        >—</div>

        <!-- Numer boczny -->
        <div
          class="text-block"
          id="tb-num"
          data-x="8%" data-y="86.85%"
          data-align="left"
          data-fs="4.9vw"
          data-color="#000"
          data-fw="700"
        >—</div>

      </div>
    </div>
  </div>

  <!-- Skrypt oblicza dokładny „cykl” przesuwu -->
  <script>
    function setMarqueeCycle() {
      const track = document.querySelector('.logo-track');
      if (!track) return;

      const firstImg = track.querySelector('img');
      if (!firstImg) return;

      const st   = getComputedStyle(track);
      const gap  = parseFloat(st.columnGap || st.gap) || 0;
      const w    = firstImg.getBoundingClientRect().width;
      const cycle = Math.ceil(w + gap);
      track.style.setProperty('--cycle', cycle + 'px');
    }

    window.addEventListener('load', () => {
      setMarqueeCycle();
      window.addEventListener('resize', setMarqueeCycle);
    });
  </script>

  <!-- Skrypt do bloków tekstowych i odczytu parametrów -->
  <script>
    /* ========= GLOBALNE ZMIENNE ========= */
    let startMs = null;
    let endMs   = null;

    function applyTextBlockAttributes() {
      document.querySelectorAll('.text-block').forEach(el => {
        const norm = v => (typeof v === 'string' ? v.replace(',', '.') : v);
        let { x, y, fs, color, fw, bg } = el.dataset;
        x  = norm(x);
        y  = norm(y);
        fs = norm(fs);
        if (x) el.style.setProperty('--x', x);
        if (y) el.style.setProperty('--y', y);
        if (fs) el.style.setProperty('--fs', fs);
        if (color) el.style.setProperty('--color', color);
        if (fw) el.style.setProperty('--fw', fw);
        if (bg) el.style.setProperty('--bg', bg);
      });
    }

    function parseIso(iso) {
      if (!iso) return null;
      const ms = Date.parse(iso);
      return Number.isNaN(ms) ? null : new Date(ms);
    }

    function formatDatePLCompact(dt) {
      const y = dt.getFullYear();
      const m = String(dt.getMonth() + 1).padStart(2, '0');
      const d = String(dt.getDate()).padStart(2, '0');
      const hh = String(dt.getHours()).padStart(2, '0');
      const mm = String(dt.getMinutes()).padStart(2, '0');
      const ss = String(dt.getSeconds()).padStart(2, '0');
      return `${y}.${m}.${d}, ${hh}:${mm}:${ss}`;
    }

    function formatMinutesSeconds(ms) {
      if (ms <= 0) return '0m 00s';
      const totalSec = Math.floor(ms / 1000);
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      return `${min}m ${String(sec).padStart(2, '0')}s`;
    }

    function initTicketOverlay() {
      // Ustaw pozycje jak najszybciej
      try { applyTextBlockAttributes(); } catch (e) { console.error(e); }

      const params = new URLSearchParams(window.location.search);
      const numStr     = params.get('num');
      const tsStartStr = params.get('ts_start'); // ISO: teraz - 1 min (ustawiane w index.html)
      const tsEndStr   = params.get('ts_end');   // ISO: teraz + 59 min (ustawiane w index.html)

      const elNum       = document.getElementById('tb-num');
      const elCountdown = document.getElementById('tb-countdown');
      const elElapsed   = document.getElementById('tb-elapsed');

      // Numer
      const num = Number.parseInt(numStr ?? '', 10);
      if (elNum) elNum.textContent = Number.isFinite(num) ? String(num) : '—';

      // Parsowanie czasów → zapis globalnie (ms)
      const startDt = parseIso(tsStartStr);
      const endDt   = parseIso(tsEndStr);
      startMs = startDt ? startDt.getTime() : null;
      endMs   = endDt   ? endDt.getTime()   : null;

      // Wstaw czas startu we WSZYSTKIE miejsca oznaczone .js-start-time
      document.querySelectorAll('.js-start-time').forEach(el => {
        el.textContent = startMs ? formatDatePLCompact(new Date(startMs)) : '—';
      });

      // Wstaw czas końca we WSZYSTKIE miejsca oznaczone .js-valid-to
      document.querySelectorAll('.js-valid-to').forEach(el => {
        el.textContent = endMs ? formatDatePLCompact(new Date(endMs)) : '—';
      });

      // Liczniki
      if (endMs) {
        const update = () => {
          const now = Date.now();

          // w dół do końca
          const msLeft = endMs - now;
          if (elCountdown) elCountdown.textContent = formatMinutesSeconds(msLeft);

          // w górę od skasowania (ts_start)
          if (startMs && elElapsed) {
            const msUp = Math.max(0, now - startMs);
            elElapsed.textContent = formatMinutesSeconds(msUp);
          } else if (elElapsed) {
            elElapsed.textContent = '—';
          }
        };

        update();
        const timerId = setInterval(() => {
          update();
          if (Date.now() >= endMs) clearInterval(timerId);
        }, 1000);
      } else {
        if (elCountdown) elCountdown.textContent = '—';
        if (elElapsed)   elElapsed.textContent   =
          startMs ? formatMinutesSeconds(Date.now() - startMs) : '—';
      }
    }

    // Ustaw pozycje już po zbudowaniu DOM
    document.addEventListener('DOMContentLoaded', () => {
      try { applyTextBlockAttributes(); } catch (e) { console.error(e); }
    });

    // Główna logika biletu po załadowaniu obrazka (finalne wymiary)
    window.addEventListener('load', initTicketOverlay);

    // Aktualizacja (na wszelki wypadek) po resize
    window.addEventListener('resize', applyTextBlockAttributes);
  </script>
</body>
</html>
