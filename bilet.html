<!DOCTYPE html>
<html lang="pl">
<head>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Carlito:wght@400;700&display=swap">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bilet ZTM Kielce</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow-x: hidden;      /* bez poziomego scrollu */
      background: #eaeaea;     /* tło wokół biletu */
      font-family: "Carlito", Arial, sans-serif;
    }

    /* Centrowanie makiety na ekranie */
    .page {
      display: flex;
      justify-content: center;
    }

    /* Kontener strony-biletu */
    .ticket {
      position: relative;      /* kontekst dla absolutnych pozycji (logo, overlay) */
      display: inline-block;
      line-height: 0;
      user-select: none;
    }

    /* Tło jako <img> (rozciąga się do 100% szerokości kontenera) */
    .ticket img.bg {
      display: block;
      width: 100%;
      height: auto;
    }

    /* SCENA animacji: nad tłem, pozycje w % względem tła */
    .logo-stage {
      position: absolute;
      top: 28%;            /* pionowo względem wysokości tła */
      left: 5.4%;
      width: 89%;
      height: 47px;
      overflow: hidden;    /* obcięcie spoza sceny */
      pointer-events: none;
      z-index: 1;
    }

    /* Taśma (dwie kopie logo dla bezszwowości) */
    .logo-track {
      position: absolute;
      top: 50%;
      display: flex;
      align-items: center;
      gap: 245px;                                /* w razie potrzeby zmień np. na 90px */
      transform: translateY(-50%);               /* centrowanie po Y */
      animation: marqueeCycle var(--duration, 10s) linear infinite;
      animation-direction: reverse;              /* z lewej → w prawo */
      will-change: transform;
    }

    .logo-track img {
      height: 37px;         /* wysokość logotypu */
      flex: 0 0 auto;
      display: block;
    }

    /* Animacja: przesunięcie o dokładny „cykl” (szerokość logo + gap) – cykl ustawiany w JS do --cycle */
    @keyframes marqueeCycle {
      from { transform: translate(0, -50%); }
      to   { transform: translate(calc(var(--cycle, 0px) * -1), -50%); }
    }

    /* === Overlay i bloki tekstowe (konfigurowalne pozycje) === */
    .overlay {
      position: absolute;
      inset: 0;        /* pełen obszar tła */
      z-index: 2;      /* nad animacją logo */
      pointer-events: none;
      line-height: 1.2;
    }

    .text-block {
      position: absolute;
      /* Pozycje nadawane z atrybutów data-x / data-y (w %) → mapowane na zmienne CSS */
      top: var(--y, 0%);
      left: var(--x, 0%);
      /* Punkt odniesienia (anchor) zależny od data-align: */
      transform: translate(-50%, -50%); /* domyślnie center */
      font-size: clamp(10px, var(--fs, 1.8vw), 26px);
      color: var(--color, #000);
      font-weight: var(--fw, 600);
      background: var(--bg, transparent);
      padding: 2px 6px;
      border-radius: 6px;
      white-space: nowrap;
      text-shadow: 0 1px 0 rgba(255,255,255,0.4);
    }
    /* Wyrównanie – zmiana transform poprzez atrybut data-align */
    .text-block[data-align="left"]   { transform: translate(0%,   -50%); text-align: left; }
    .text-block[data-align="center"] { transform: translate(-50%, -50%); text-align: center; }
    .text-block[data-align="right"]  { transform: translate(-100%,-50%); text-align: right; }
  </style>
</head>
<body>

  <div class="page">
    <div class="ticket">
      <!-- TŁO -->
      <img src="ztm.png" alt="tło biletu" class="bg">

      <!-- ANIMACJA LOGO (bezszwowo, z lewej → w prawo) -->
      <div class="logo-stage">
        <div class="logo-track">
          <img src="logo_ztm.png" alt="logo" />
          <img src="logo_ztm.png" alt="logo" />
        </div>
      </div>

      <!-- Nakładka z blokami tekstowymi (pozycje ustawiasz atrybutami data-*) -->
      <div class="overlay" id="overlay">
        <!-- Numer boczny -->
        <div
          class="text-block"
          id="tb-num"
          data-x="8%" data-y="86.85%"
          data-align="left"
          data-fs="4.9vw"
          data-color="#000"
          data-fw="700"
        >—</div>

        <!-- Start lokalny (format: rrrr.mm.dd, hh:mm:ss) -->
        <div
          class="text-block"
          id="tb-start-local"
          data-x="8%" data-y="55.2%"
          data-align="left"
          data-fs="4.9vw"
          data-color="#000"
        >—</div>

        <!-- Koniec lokalny (format: rrrr.mm.dd, hh:mm:ss) -->
        <div
          class="text-block"
          id="tb-end-local"
          data-x="8%" data-y="43.5%"
          data-align="left"
          data-fs="4.9vw"
          data-color="#000"
        >—</div>

        <!-- Odliczanie do końca -->
        <div
          class="text-block"
          id="tb-countdown"
          data-x="50%" data-y="9.6%"
          data-align="center"
          data-fs="10.0vw"
          data-fw="800"
          data-color="#2b7729"
        >—</div>

        <!-- Czas od skasowania (licznik w górę, ten sam format m i s) -->
        <div
          class="text-block"
          id="tb-elapsed"
          data-x="8%" data-y="59.3%"
          data-align="left"
          data-fs="4.9vw"
          data-color="#b02432"
          data-fw="700"
        >—</div>
      </div>

    </div>
  </div>

  <!-- Skrypt oblicza dokładny „cykl” przesuwu: szerokość jednego logo + gap -->
  <script>
    function setMarqueeCycle() {
      const track = document.querySelector('.logo-track');
      if (!track) return;

      const firstImg = track.querySelector('img');
      if (!firstImg) return;

      // Bieżące style (gap)
      const st   = getComputedStyle(track);
      const gap  = parseFloat(st.columnGap || st.gap) || 0;

      // Faktyczna szerokość pierwszego logo
      const w = firstImg.getBoundingClientRect().width;

      // Cykl = szerokość jednego logo + gap
      const cycle = Math.ceil(w + gap);

      // Przekazanie do CSS jako zmienna
      track.style.setProperty('--cycle', cycle + 'px');
    }

    // Ustaw po przeliczeniu layoutu (po obrazkach) i reaguj na zmianę rozmiaru
    window.addEventListener('load', () => {
      setMarqueeCycle();
      window.addEventListener('resize', setMarqueeCycle);
    });
  </script>

  <!-- Skrypt do bloków tekstowych i odczytu parametrów -->
  <script>
    // Ustawienie pozycji i stylu bloków na podstawie atrybutów data-*
    function applyTextBlockAttributes() {
      document.querySelectorAll('.text-block').forEach(el => {
        const { x, y, fs, color, fw, bg } = el.dataset;
        if (x) el.style.setProperty('--x', x);
        if (y) el.style.setProperty('--y', y);
        if (fs) el.style.setProperty('--fs', fs);
        if (color) el.style.setProperty('--color', color);
        if (fw) el.style.setProperty('--fw', fw);
        if (bg) el.style.setProperty('--bg', bg);
        // wyrównanie obsługuje atrybut data-align (CSS)
      });
    }

    // Parsowanie ISO -> Date z walidacją
    function parseIso(iso) {
      if (!iso) return null;
      const ms = Date.parse(iso);
      return Number.isNaN(ms) ? null : new Date(ms);
    }

    // Format: rrrr.mm.dd, hh:mm:ss (np. 2026.02.14, 09:42:07)
    function formatDatePLCompact(dt) {
      const y = dt.getFullYear();
      const m = String(dt.getMonth() + 1).padStart(2, '0');
      const d = String(dt.getDate()).padStart(2, '0');
      const hh = String(dt.getHours()).padStart(2, '0');
      const mm = String(dt.getMinutes()).padStart(2, '0');
      const ss = String(dt.getSeconds()).padStart(2, '0');
      return `${y}.${m}.${d}, ${hh}:${mm}:${ss}`;
    }

    // Wspólny format m i s (np. 12m 07s)
    function formatMinutesSeconds(ms) {
      if (ms <= 0) return '0m 00s';
      const totalSec = Math.floor(ms / 1000);
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      return `${min}m ${String(sec).padStart(2, '0')}s`;
    }

    function initTicketOverlay() {
      // Ustaw pozycje jak najszybciej
      try { applyTextBlockAttributes(); } catch (e) { console.error(e); }

      const params = new URLSearchParams(window.location.search);
      const numStr     = params.get('num');
      const tsStartStr = params.get('ts_start'); // ISO: teraz - 1 min (ustawiane w index.html)
      const tsEndStr   = params.get('ts_end');   // ISO: teraz + 59 min (ustawiane w index.html)

      const elNum       = document.getElementById('tb-num');
      const elStartLoc  = document.getElementById('tb-start-local');
      const elEndLoc    = document.getElementById('tb-end-local');
      const elCountdown = document.getElementById('tb-countdown');
      const elElapsed   = document.getElementById('tb-elapsed');

      
// Numer
const num = Number.parseInt(numStr ?? '', 10);
if (elNum) {
  elNum.textContent = Number.isFinite(num) ? String(num) : '—';
}


      // Czas
      const startDt = parseIso(tsStartStr);
      const endDt   = parseIso(tsEndStr);

      if (elStartLoc) elStartLoc.textContent = startDt
        ? `${formatDatePLCompact(startDt)}`
        : '—';

      if (elEndLoc) elEndLoc.textContent = endDt
        ? `${formatDatePLCompact(endDt)}`
        : '—';

      // Liczniki
      if (endDt) {
        const update = () => {
          const now = Date.now();

          // w dół do końca
          const msLeft = endDt.getTime() - now;
          if (elCountdown) elCountdown.textContent = formatMinutesSeconds(msLeft);

          // w górę od skasowania (ts_start), ten sam format m i s
          if (startDt && elElapsed) {
            const msUp = Math.max(0, now - startDt.getTime());
            elElapsed.textContent = formatMinutesSeconds(msUp);
          } else if (elElapsed) {
            elElapsed.textContent = '—';
          }
        };

        update();
        const timerId = setInterval(() => {
          update();
          if (Date.now() >= endDt.getTime()) clearInterval(timerId);
        }, 1000);
      } else {
        if (elCountdown) elCountdown.textContent = 'Pozostało: —';
        if (elElapsed)   elElapsed.textContent   =
          startDt ? ('Minęło: ' + formatMinutesSeconds(Date.now() - startDt.getTime())) : '—';
      }
    }

    // Ustaw pozycje już po zbudowaniu DOM (bez czekania na obrazki)
    document.addEventListener('DOMContentLoaded', () => {
      try { applyTextBlockAttributes(); } catch (e) { console.error(e); }
    });

    // Główna logika biletu po pełnym załadowaniu (gdy obrazek ma już finalne wymiary)
    window.addEventListener('load', initTicketOverlay);

    // Aktualizacja (na wszelki wypadek) po zmianie rozmiaru
    window.addEventListener('resize', applyTextBlockAttributes);
  </script>
</body>
</html>













