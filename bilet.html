<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bilet ZTM Kielce</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow-x: hidden;      /* без горизонтального скролу */
      background: #eaeaea;     /* фон навколо квитка */
      font-family: "Carlito", Arial, sans-serif;
    }

    /* Центруємо макет на екрані */
    .page {
      display: flex;
      justify-content: center;
    }

    /* Контейнер сторінки-квитка */
    .ticket {
      position: relative;      /* базовий контекст для абсолютного позиціювання .logo-stage */
      display: inline-block;
      line-height: 0;
      user-select: none;
    }

    /* Фон як <img> (тягнеться на 100% ширини контейнера) */
    .ticket img.bg {
      display: block;
      width: 100%;
      height: auto;
    }

    /* СЦЕНА анімації: поверх фону, позиції у % від фону */
    .logo-stage {
      position: absolute;
      top: 28%;            /* позиція по вертикалі від висоти фону */
      left: 5.4%;
      width: 89%;
      height: 47px;
      overflow: hidden;    /* обрізаємо за межами сцени */
      pointer-events: none;
      z-index: 1;
    }

    /* СТРІЧКА (дві копії логотипу підряд для безшовності) */
    .logo-track {
      position: absolute;
      top: 50%;
      display: flex;
      align-items: center;
      gap: 245px;                                /* за потреби можеш поставити, наприклад, 90px */
      transform: translateY(-50%);             /* центрування по Y */
      animation: marqueeCycle var(--duration, 10s) linear infinite;
      animation-direction: reverse;            /* зліва → направо */
      will-change: transform;
    }

    .logo-track img {
      height: 37px;         /* висота логотипу */
      flex: 0 0 auto;
      display: block;
    }

    /* Анімація: зсув рівно на ширину одного лого + gap (встановлюється з JS у --cycle) */
    @keyframes marqueeCycle {
      from { transform: translate(0, -50%); }
      to   { transform: translate(calc(var(--cycle, 0px) * -1), -50%); }
    }

    /* === Overlay i bloki tekstowe (konfigurowalne pozycje) === */
    .overlay {
      position: absolute;
      inset: 0;        /* pełen obszar biletu */
      z-index: 2;      /* nad animacją logo */
      pointer-events: none;
      line-height: 1.2;
    }
    .text-block {
      position: absolute;
      /* Pozycje będą nadawane z atrybutów data-x / data-y (w %) */
      top: var(--y, 0%);
      left: var(--x, 0%);
      /* Punkt odniesienia (anchor) zależny od data-align: */
      transform: translate(-50%, -50%); /* domyślnie center */
      font-size: clamp(10px, var(--fs, 1.8vw), 26px);
      color: var(--color, #000);
      font-weight: var(--fw, 600);
      background: var(--bg, transparent);
      padding: 2px 6px;
      border-radius: 6px;
      white-space: nowrap;
      text-shadow: 0 1px 0 rgba(255,255,255,0.4);
    }
    /* Wyrównanie – zmieniamy transform X przez atrybut data-align */
    .text-block[data-align="left"]   { transform: translate(0%,   -50%); text-align: left; }
    .text-block[data-align="center"] { transform: translate(-50%, -50%); text-align: center; }
    .text-block[data-align="right"]  { transform: translate(-100%,-50%); text-align: right; }
  </style>
</head>
<body>

  <div class="page">
    <div class="ticket">
      <!-- ФОН -->
      <img src="ztm.png" alt="tło biletu" class="bg">

      <!-- АНІМАЦІЯ ЛОГОТИПУ (bezszwowo, z lewej → w prawo) -->
      <div class="logo-stage">
        <div class="logo-track">
          <img src="logo_ztm.png" alt="logo" />
          <img src="logo_ztm.png" alt="logo" />
        </div>
      </div>

      <!-- Nakładka z blokami tekstowymi (pozycje ustawiasz atrybutami data-*) -->
      <div class="overlay" id="overlay">
        <!-- Numer boczny -->
        <div
          class="text-block"
          id="tb-num"
          data-x="8%" data-y="15%"
          data-align="left"
          data-fs="16.3px"
          data-color="#000"
          data-fw="700"
        >Numer: —</div>

        <!-- Start lokalny (format: rrrr.mm.dd, godz:min:sec) -->
        <div
          class="text-block"
          id="tb-start-local"
          data-x="8%" data-y="25%"
          data-align="left"
          data-fs="16.3px"
          data-color="#000"
        >Start: —</div>

        <!-- Koniec lokalny (format: rrrr.mm.dd, godz:min:sec) -->
        <div
          class="text-block"
          id="tb-end-local"
          data-x="92%" data-y="25%"
          data-align="right"
          data-fs="16.3px"
          data-color="#000"
        >Ważny do: —</div>

        <!-- Odliczanie do końca -->
        <div
          class="text-block"
          id="tb-countdown"
          data-x="50%" data-y="84%"
          data-align="center"
          data-fs="2.2vw"
          data-fw="800"
        >Pozostało: —</div>

        <!-- Czas od skasowania (licznik w górę, taki sam styl jak Pozostało: m i s) -->
        <div
          class="text-block"
          id="tb-elapsed"
          data-x="8%" data-y="32%"
          data-align="left"
          data-fs="16.3px"
          data-color="#000"
          data-fw="700"
        >Minęło: —</div>
      </div>

    </div>
  </div>

  <!-- Skrypt oblicza dokładny „cykl” przesuwu: szerokość jednego logo + gap -->
  <script>
    function setMarqueeCycle() {
      const track = document.querySelector('.logo-track');
      if (!track) return;

      const firstImg = track.querySelector('img');
      if (!firstImg) return;

      // Bieżące style (gap)
      const st   = getComputedStyle(track);
      const gap  = parseFloat(st.columnGap || st.gap) || 0;

      // Faktyczna szerokość pierwszego logo
      const w = firstImg.getBoundingClientRect().width;

      // Cykl = szerokość jednego logo + gap
      const cycle = Math.ceil(w + gap);

      // Przekazanie do CSS jako zmienna
      track.style.setProperty('--cycle', cycle + 'px');
    }

    window.addEventListener('load', () => {
      setMarqueeCycle();
      window.addEventListener('resize', setMarqueeCycle);
    });
  </script>

  <!-- Skrypt do bloków tekstowych i odczytu parametrów -->
  <script>
    // Ustawienie pozycji i stylu bloków na podstawie atrybutów data-*
    function applyTextBlockAttributes() {
      document.querySelectorAll('.text-block').forEach(el => {
        const { x, y, fs, color, fw, bg } = el.dataset;
        if (x) el.style.setProperty('--x', x);
        if (y) el.style.setProperty('--y', y);
        if (fs) el.style.setProperty('--fs', fs);
        if (color) el.style.setProperty('--color', color);
        if (fw) el.style.setProperty('--fw', fw);
        if (bg) el.style.setProperty('--bg', bg);
        // wyrównanie obsługuje atrybut data-align (CSS)
      });
    }

    // Parsowanie ISO -> Date z walidacją
    function parseIso(iso) {
      if (!iso) return null;
      const ms = Date.parse(iso);
      return Number.isNaN(ms) ? null : new Date(ms);
    }

    // Format: rrrr.mm.dd, godz:min:sec (np. 2026.02.14, 09:42:07)
    function formatDatePLCompact(dt) {
      const y = dt.getFullYear();
      const m = String(dt.getMonth() + 1).padStart(2, '0');
      const d = String(dt.getDate()).padStart(2, '0');
      const hh = String(dt.getHours()).padStart(2, '0');
      const mm = String(dt.getMinutes()).padStart(2, '0');
      const ss = String(dt.getSeconds()).padStart(2, '0');
      return `${y}.${m}.${d}, ${hh}:${mm}:${ss}`;
    }

    // Wspólny format m i s (np. 12m 07s), używany dla „Pozostało” i „Minęło”
    function formatMinutesSeconds(ms) {
      if (ms <= 0) return '0m 00s';
      const totalSec = Math.floor(ms / 1000);
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      return `${min}m ${String(sec).padStart(2, '0')}s`;
    }

    function initTicketOverlay() {
      applyTextBlockAttributes();

      const params = new URLSearchParams(window.location.search);
      const numStr     = params.get('num');
      const tsStartStr = params.get('ts_start'); // ISO: teraz - 1 min (ustawiane w index.html)
      const tsEndStr   = params.get('ts_end');   // ISO: teraz + 59 min (ustawiane w index.html)

      const elNum       = document.getElementById('tb-num');
      const elStartLoc  = document.getElementById('tb-start-local');
      const elEndLoc    = document.getElementById('tb-end-local');
      const elCountdown = document.getElementById('tb-countdown');
      const elElapsed   = document.getElementById('tb-elapsed');

      // Numer
      const num = Number.parseInt(numStr ?? '', 10);
      elNum.textContent = Number.isFinite(num) ? `Numer: ${num}` : 'Numer: —';

      // Czas
      const startDt = parseIso(tsStartStr);
      const endDt   = parseIso(tsEndStr);

      elStartLoc.textContent = startDt
        ? `Start: ${formatDatePLCompact(startDt)}`
